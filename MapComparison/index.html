<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <!-- M√©ta tag essentiel pour le responsive sur mobile -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>√âvolution d'Oraxia (Tale of Oraxia)</title>
    <!-- Chargement de Tailwind CSS pour un design moderne et responsive -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Utilisation d'une propri√©t√© CSS variable pour stocker la position du slider */
        .comparison-slider-container {
            --position: 50%;
            user-select: none;
            cursor: grab;
            /* Emp√™che le d√©filement du navigateur lors du glisser */
            touch-action: none; 
        }

        /* Curseur sp√©cifique pour le panoramique */
        .cursor-grabbing {
            cursor: grabbing !important;
        }
        
        /* Conteneur de l'image "Apr√®s" - Sa largeur est coup√©e par le clip-path */
        /* NOTE: La logique clip-path est invers√©e pour que l'image "APR√àS" soit √† droite de la poign√©e */
        .image-apres-wrapper {
            /* Coupe la partie gauche de l'image. L'image "APRES" est visible de --position √† 100% (c'est-√†-dire √† droite) */
            clip-path: inset(0 0 0 var(--position));
        }

        /* La poign√©e (handle) se positionne √† la valeur de la variable */
        .slider-handle {
            left: var(--position);
            transform: translateX(-50%); /* Centrage horizontal de la poign√©e */
            /* Assure que la poign√©e reste au-dessus de tout et est r√©active au tactile */
            touch-action: none; 
        }

        /* Styles pour la poign√©e du slider */
        .handle-line {
            width: 4px; /* Ligne verticale */
        }

        .handle-circle {
            width: 40px;
            height: 40px;
        }
        
        /* Centrer le contenu dans le cercle */
        .handle-content {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }
        
        /* Les images pour la gestion du zoom/panoramique */
        .comparison-image {
            position: absolute;
            width: 100%;
            height: 100%;
            /* D√©finition des transitions pour un mouvement de zoom/pan plus doux */
            transition: transform 0.15s ease-out;
            /* Le zoom commence depuis le coin haut-gauche (0 0) */
            transform-origin: 0 0; 
        }

    </style>
</head>
<body class="bg-gray-900 min-h-screen p-4 flex flex-col items-center font-sans">

    <header class="text-center mb-8 w-full max-w-4xl">
        <h1 class="text-4xl font-extrabold text-blue-400">
            √âvolution d'Oraxia (Tale of Oraxia) üó∫Ô∏è
        </h1>
        <p class="text-xl text-gray-400 mt-2">
            Visualisez les changements entre les mises √† jour.
        </p>
    </header>

    <main class="w-full max-w-4xl">

        <!-- S√©lecteurs de versions -->
        <div class="flex flex-col sm:flex-row justify-between gap-4 mb-6 p-4 bg-gray-800 rounded-xl shadow-lg border-2 border-gray-700">
            
            <!-- S√©lecteur AVANT -->
            <div class="flex-1">
                <label for="versionAvant" class="block text-sm font-medium text-red-400 mb-1">
                    Version AVANT :
                </label>
                <select id="versionAvant" class="w-full p-2 rounded-lg bg-gray-700 text-white border border-gray-600 focus:ring-red-500 focus:border-red-500 transition-colors">
                    <!-- Les options seront remplies par JavaScript -->
                </select>
            </div>
            
            <!-- S√©lecteur APR√àS -->
            <div class="flex-1">
                <label for="versionApres" class="block text-sm font-medium text-green-400 mb-1">
                    Version APR√àS :
                </label>
                <select id="versionApres" class="w-full p-2 rounded-lg bg-gray-700 text-white border border-gray-600 focus:ring-green-500 focus:border-green-500 transition-colors">
                    <!-- Les options seront remplies par JavaScript -->
                </select>
            </div>

        </div>


        <!-- Conteneur principal du slider -->
        <div id="comparisonContainer" 
             class="comparison-slider-container relative w-full aspect-video shadow-2xl rounded-xl overflow-hidden border-4 border-gray-700 bg-gray-800 transition-all duration-300 ease-in-out">

            <!-- 1. Image de base (VERSION AVANT) - Z-index 10. Visible √† gauche de la poign√©e. -->
            <img id="imageAvant" 
                 class="comparison-image absolute inset-0 z-10" 
                 src="" 
                 alt="Carte Avant Mise √† Jour">
            
            <!-- 2. Conteneur de l'image de dessus (VERSION APR√àS) - Z-index 20. Clipp√© pour √™tre visible √† droite. -->
            <div class="image-apres-wrapper absolute inset-0 z-20 overflow-hidden bg-gray-600">
                <img id="imageApres" 
                     class="comparison-image absolute inset-0" 
                     src="" 
                     alt="Carte Apr√®s Mise √† Jour">
            </div>

            <!-- 3. La poign√©e (Handle) draggable/tactile - Z-index 30 -->
            <div id="sliderHandle" 
                 class="slider-handle absolute top-0 bottom-0 z-30 flex items-center justify-center 
                        text-white bg-transparent">
                
                <!-- La ligne verticale de la poign√©e -->
                <div class="handle-line h-full bg-white shadow-lg"></div>

                <!-- Le cercle central avec des fl√®ches -->
                <div class="handle-circle absolute bg-white p-1 rounded-full shadow-xl 
                            border-4 border-gray-900/50 hover:scale-110 transition-transform duration-150 ease-out">
                    <div class="handle-content text-gray-900">
                        <!-- Ic√¥nes des fl√®ches (SVG inline) -->
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6">
                            <polyline points="15 17 20 12 15 7"></polyline>
                            <polyline points="9 17 4 12 9 7"></polyline>
                        </svg>
                    </div>
                </div>
            </div>

            <!-- 4. √âtiquettes de version dynamiques - Z-index 40 -->
            <div id="labelAvant" class="absolute top-3 left-3 p-1.5 bg-red-800/80 text-white text-xs font-bold rounded-lg z-40 shadow-md"></div>
            <div id="labelApres" class="absolute top-3 right-3 p-1.5 bg-green-800/80 text-white text-xs font-bold rounded-lg z-40 shadow-md"></div>
            
        </div>
        
    </main>
    
    <p class="mt-6 text-sm text-gray-500 max-w-4xl text-center">
        <span class="text-blue-400 font-bold">Instructions :</span> 
        Choisissez deux versions et utilisez le s√©parateur pour comparer l'√©volution. 
        Pour **zoomer/d√©zoomer** (Desktop), utilisez la molette de la souris. 
        Pour **d√©placer la carte** (Panoramique / Mobile), utilisez un doigt pour glisser (le zoom doit √™tre sup√©rieur √† 1.0).
        Utilisez **deux doigts** pour le **Zoom Tactile (Pinch-to-Zoom)** sur mobile.
        **Nouveau !** Effectuez un **double-tap** (ou double-clic) sur la carte pour zoomer/d√©zoomer rapidement.
    </p>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- D√©finition des versions de carte (CHEMINS D'ACC√àS RELATIFS R√âTABLIS) ---
            const mapVersions = [
                { id: 'v1', name: "Alpha (v0.0)", url: "./Maps/alpha.png" }, 
                { id: 'v2', name: "Beta (v1.0)", url: "./Maps/beta.png" },
                { id: 'v3', name: "Beta v1 - Oraxoween (v1.1)", url: "./Maps/beta-v2.png" },
                { id: 'v4', name: "Beta v2 (v1.2)", url: "./Maps/beta-v3.png" },
                { id: 'v5', name: "Beta v3 (v1.3)", url: "./Maps/beta-v4.png" },
                { id: 'v6', name: "Beta v4 - Biomes Classics (v1.4)", url: "./Maps/beta-v5.png" },
                { id: 'v7', name: "Beta v5 - Debut d'Ankatar (v1.5)", url: "./Maps/beta-v6.png" },
            ];

            const FALLBACK_PLACEHOLDER = "https://placehold.co/1024x576/374151/D1D5DB?text=ERREUR+DE+CHARGEMENT";
            const MIN_SCALE = 1.0;
            const MAX_SCALE = 5.0;
            const SCALE_STEP = 0.15;
            const PAN_MARGIN_PERCENT = 0.5; // 50% de marge de d√©passement
            
            // --- Variables pour le double-tap/double-clic ---
            const DOUBLE_TAP_THRESHOLD = 300; // temps max entre deux taps pour √™tre consid√©r√© comme double-tap
            let lastTapTime = 0;
            const ZOOM_LEVEL_ON_DOUBLE_TAP = 2.5; // Niveau de zoom √† atteindre
            
            // --- √âl√©ments du DOM ---
            const container = document.getElementById('comparisonContainer');
            const handle = document.getElementById('sliderHandle');
            const selectAvant = document.getElementById('versionAvant');
            const selectApres = document.getElementById('versionApres');
            const imageAvant = document.getElementById('imageAvant');
            const imageApres = document.getElementById('imageApres');
            const labelAvant = document.getElementById('labelAvant');
            const labelApres = document.getElementById('labelApres');
            const style = container.style;
            
            // --- Variables de l'√©tat du composant ---
            let isSliderDragging = false; 
            let isPanDragging = false;    
            let containerRect;            
            let lastX = 0;
            let lastY = 0;   
            
            // Variables pour le Pinch-to-Zoom
            let initialDistance = 0;
            let initialScale = MIN_SCALE;

            /**
             * Calcule la distance euclidienne entre deux points de contact.
             * @param {TouchList} touches - Liste des points de contact.
             */
            function getDistance(touches) {
                if (touches.length < 2) return 0;
                return Math.hypot(
                    touches[1].clientX - touches[0].clientX, 
                    touches[1].clientY - touches[0].clientY
                );
            }

            // √âtat de la vue (Zoom et Panoramique)
            let viewState = {
                scale: MIN_SCALE, 
                offsetX: 0,       
                offsetY: 0        
            };

            // --- Fonctions utilitaires ---

            /**
             * Applique les transformations de zoom et de panoramique aux deux images via CSS transform.
             */
            function updateImageTransform() {
                const transform = `translate(${viewState.offsetX}px, ${viewState.offsetY}px) scale(${viewState.scale})`;
                imageAvant.style.transform = transform;
                imageApres.style.transform = transform;
            }

            /**
             * Applique les contraintes de d√©placement pour ne pas sortir du cadre.
             * Emp√™che l'image zoom√©e de laisser un espace vide dans le conteneur.
             */
            function clampPan() {
                if (!containerRect) containerRect = container.getBoundingClientRect();

                if (viewState.scale <= MIN_SCALE) {
                    // Si non zoom√©, on r√©initialise les d√©calages
                    viewState.offsetX = 0;
                    viewState.offsetY = 0;
                } else {
                    const scaledWidth = containerRect.width * viewState.scale;
                    const scaledHeight = containerRect.height * viewState.scale;

                    // Calcul de la marge de d√©passement (50% de la taille du conteneur)
                    const marginX = containerRect.width * PAN_MARGIN_PERCENT;
                    const marginY = containerRect.height * PAN_MARGIN_PERCENT;

                    // Limites avec marge :
                    // maxPanX (d√©placement √† droite): permet au bord gauche de l'image de d√©passer jusqu'√† marginX
                    const maxPanX = marginX; 
                    // minPanX (d√©placement √† gauche): permet au bord droit de l'image de d√©passer jusqu'√† marginX
                    const minPanX = containerRect.width - scaledWidth - marginX; 
                    
                    // maxPanY (d√©placement vers le bas): permet au bord sup√©rieur de l'image de d√©passer jusqu'√† marginY
                    const maxPanY = marginY;
                    // minPanY (d√©placement vers le haut): permet au bord inf√©rieur de l'image de d√©passer jusqu'√† marginY
                    const minPanY = containerRect.height - scaledHeight - marginY;


                    viewState.offsetX = Math.max(minPanX, Math.min(maxPanX, viewState.offsetX));
                    viewState.offsetY = Math.max(minPanY, Math.min(maxPanY, viewState.offsetY));
                }

                updateImageTransform();
            }

            /**
             * G√®re l'√©v√©nement de la molette pour zoomer/d√©zoomer (Desktop).
             * @param {WheelEvent} e - L'√©v√©nement molette.
             */
            function handleZoom(e) {
                // Emp√™cher le d√©filement de la page
                e.preventDefault(); 
                
                // D√©terminer la direction du zoom (deltaY est n√©gatif si on scroll vers le haut = zoom)
                const delta = e.deltaY < 0 ? SCALE_STEP : -SCALE_STEP;

                let newScale = viewState.scale + delta;
                // Clamper le zoom entre les limites min et max
                newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));

                if (newScale === viewState.scale) return;

                // Calculer le point focal pour le zoom
                containerRect = container.getBoundingClientRect();
                const mouseX = e.clientX - containerRect.left;
                const mouseY = e.clientY - containerRect.top;

                // Facteur de changement de zoom
                const zoomFactor = newScale / viewState.scale;

                // Appliquer la correction de panoramique pour centrer le zoom sur le curseur
                viewState.offsetX = mouseX - (mouseX - viewState.offsetX) * zoomFactor;
                viewState.offsetY = mouseY - (mouseY - viewState.offsetY) * zoomFactor;
                
                // Mettre √† jour l'√©tat et appliquer les contraintes
                viewState.scale = newScale;
                clampPan(); 
            }
            
            /**
             * G√®re le zoom/d√©zoom suite √† un double-tap/double-clic.
             * @param {Event} e - L'√©v√©nement (mousedown ou touchstart).
             */
            function handleDoubleTapZoom(e) {
                // D√©terminer la position du clic/tap (utilise clientX/Y ou le premier point de contact)
                const clientX = e.clientX || (e.touches ? e.touches[0].clientX : null);
                const clientY = e.clientY || (e.touches ? e.touches[0].clientY : null);
                
                if (clientX === null || clientY === null) return;

                containerRect = container.getBoundingClientRect();
                const centerX = containerRect.width / 2;
                const centerY = containerRect.height / 2;
                
                if (viewState.scale > MIN_SCALE) {
                    // Si d√©j√† zoom√©, d√©zoomer
                    viewState.scale = MIN_SCALE;
                    viewState.offsetX = 0;
                    viewState.offsetY = 0;
                } else {
                    // Si non zoom√©, zoomer au niveau pr√©d√©fini (2.5x)
                    viewState.scale = ZOOM_LEVEL_ON_DOUBLE_TAP;
                    
                    // Calcul du point focal (position relative dans le conteneur)
                    const focalX = clientX - containerRect.left;
                    const focalY = clientY - containerRect.top;

                    // Centrer le point focal au milieu de l'√©cran apr√®s le zoom
                    // offsetX = position_souhait√©e - (position_cliqu√©e * scale)
                    viewState.offsetX = centerX - (focalX * viewState.scale);
                    viewState.offsetY = centerY - (focalY * viewState.scale);
                }

                clampPan(); // Appliquer les contraintes et mettre √† jour l'affichage
            }


            /**
             * Calcule la nouvelle position du slider de comparaison et l'applique au CSS.
             * @param {number} clientX - Position X du curseur/doigt.
             */
            function updateSliderPosition(clientX) {
                if (!containerRect) {
                    containerRect = container.getBoundingClientRect();
                }
                
                let position = clientX - containerRect.left;

                // Clamper la position entre 0 et la largeur du conteneur
                position = Math.max(0, Math.min(position, containerRect.width));
                
                const percent = (position / containerRect.width) * 100;
                // Met √† jour la variable CSS pour l'effet de coupe
                style.setProperty('--position', `${percent}%`);
            }

            // --- Gestion des √©v√©nements de glissement (Drag) ---

            /**
             * Commence le glissement du slider de comparaison (MouseDown/TouchStart sur la poign√©e).
             */
            const startSliderDrag = (e) => {
                // V√©rifie si l'√©v√©nement provient bien de la poign√©e
                if (e.currentTarget !== handle) return;

                isSliderDragging = true;
                handle.style.cursor = 'grabbing';
                container.style.cursor = 'grabbing';
                containerRect = container.getBoundingClientRect();
                
                if (e.type.startsWith('touch')) {
                    e.preventDefault(); 
                }
                e.stopPropagation(); 
            };

            /**
             * Commence le panoramique (Pan Drag) ou le Pinch-to-Zoom (MouseDown/TouchStart sur le conteneur).
             * G√®re √©galement le double-tap/double-clic pour le zoom.
             */
            const startPanDrag = (e) => {
                // Si le clic vient de la poign√©e ou si le glissement de slider est d√©j√† actif, on sort.
                if (e.target === handle || handle.contains(e.target) || isSliderDragging) return;
                
                // --- LOGIQUE DOUBLE TAP/CLICK ---
                if (e.touches && e.touches.length === 1 || !e.touches) { // Souris ou 1 doigt
                    const currentTime = new Date().getTime();
                    const timeDiff = currentTime - lastTapTime;

                    if (timeDiff < DOUBLE_TAP_THRESHOLD && timeDiff > 0) {
                        e.preventDefault(); 
                        handleDoubleTapZoom(e);
                        lastTapTime = 0; // R√©initialiser le temps apr√®s un double-tap r√©ussi
                        return;
                    }
                    lastTapTime = currentTime;
                }
                // --- FIN LOGIQUE DOUBLE TAP/CLICK ---

                // LOGIQUE PINCH START (2 doigts)
                if (e.touches && e.touches.length === 2) {
                    // Initialiser les √©tats de pincement
                    initialDistance = getDistance(e.touches);
                    initialScale = viewState.scale;
                    e.preventDefault(); 
                    return;
                }
                
                // LOGIQUE PAN START (1 doigt ou souris)
                if (viewState.scale === MIN_SCALE) return;

                isPanDragging = true;
                container.classList.add('cursor-grabbing'); 
                containerRect = container.getBoundingClientRect();

                // Initialiser les derni√®res positions (compatible Souris et Tactile)
                lastX = e.clientX || (e.touches ? e.touches[0].clientX : 0);
                lastY = e.clientY || (e.touches ? e.touches[0].clientY : 0);
                
                if (e.touches) e.preventDefault(); 
            };
            
            /**
             * G√®re le glissement du slider, le Panoramique OU le Pinch-to-Zoom (MouseMove/TouchMove).
             */
            const onDrag = (e) => {
                // LOGIQUE PINCH-TO-ZOOM (2 doigts)
                if (e.touches && e.touches.length === 2) {
                    e.preventDefault(); 
                    isSliderDragging = false; 
                    isPanDragging = false;
                    
                    if (initialDistance === 0) {
                        initialDistance = getDistance(e.touches);
                        initialScale = viewState.scale;
                        return; // √âviter les sauts lors du premier mouvement
                    }

                    const newDistance = getDistance(e.touches);
                    let newScale = initialScale * (newDistance / initialDistance);
                    
                    newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));

                    if (newScale !== viewState.scale) {
                        const previousScale = viewState.scale;
                        
                        // Calcul du point focal (milieu du pincement)
                        containerRect = container.getBoundingClientRect();
                        const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                        const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

                        const focalX = centerX - containerRect.left;
                        const focalY = centerY - containerRect.top;
                        
                        // Ajustement du d√©calage pour maintenir le point focal
                        const zoomFactor = newScale / previousScale; 
                        viewState.offsetX = focalX - (focalX - viewState.offsetX) * zoomFactor;
                        viewState.offsetY = focalY - (focalY - viewState.offsetY) * zoomFactor;
                        
                        viewState.scale = newScale;
                    }
                    
                    clampPan();
                    return; 
                }
                
                // LOGIQUE SLIDER/PAN DRAG (1 doigt ou souris)
                if (!isSliderDragging && !isPanDragging) return;

                // R√©cup√©rer les coordonn√©es X/Y (compatible Souris et Tactile 1 doigt)
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                
                if (isSliderDragging) {
                    updateSliderPosition(clientX);
                }
                
                if (isPanDragging) {
                    // Calcul du d√©placement
                    const dx = clientX - lastX;
                    const dy = clientY - lastY;
                    
                    // Appliquer le d√©placement
                    viewState.offsetX += dx;
                    viewState.offsetY += dy;

                    // Clamper les valeurs et appliquer la transformation
                    clampPan();

                    // Mise √† jour des derni√®res positions
                    lastX = clientX;
                    lastY = clientY;
                }
                
                if (e.touches) {
                    e.preventDefault(); 
                }
            };

            /**
             * Termine le glissement (MouseUp/TouchEnd).
             */
            const endDrag = () => {
                isSliderDragging = false;
                isPanDragging = false;
                
                // R√©initialisation de l'√©tat de pincement
                initialDistance = 0; 
                initialScale = MIN_SCALE;

                handle.style.cursor = 'grab';
                container.style.cursor = 'grab';
                container.classList.remove('cursor-grabbing');
            };

            // --- Fonctions d'initialisation et de mise √† jour ---

            /**
             * Rempli les menus d√©roulants avec les versions de carte.
             */
            function populateSelects() {
                mapVersions.forEach(version => {
                    const optionAvant = new Option(version.name, version.id);
                    const optionApres = new Option(version.name, version.id);
                    selectAvant.add(optionAvant);
                    selectApres.add(optionApres);
                });

                // D√©finir les valeurs par d√©faut (avant-derni√®re et derni√®re version)
                if (mapVersions.length >= 2) {
                    selectAvant.value = mapVersions[mapVersions.length - 2].id;
                    selectApres.value = mapVersions[mapVersions.length - 1].id;
                } else if (mapVersions.length === 1) {
                    selectAvant.value = mapVersions[0].id;
                    selectApres.value = mapVersions[0].id;
                }
                
                updateImagesAndLabels();
            }

            /**
             * Met √† jour les images, les √©tiquettes et configure la gestion des erreurs.
             */
            function updateImagesAndLabels() {
                const idAvant = selectAvant.value;
                const idApres = selectApres.value;

                const versionA = mapVersions.find(v => v.id === idAvant);
                const versionB = mapVersions.find(v => v.id === idApres);
                
                const COLOR_CLASSES = {
                    avant: { success: 'bg-red-800/80', error: 'bg-gray-600/90' },
                    apres: { success: 'bg-green-800/80', error: 'bg-gray-600/90' }
                };

                const loadImage = (imgElement, version, labelElement, baseType) => {
                    if (!version) return;
                    
                    const colorSet = COLOR_CLASSES[baseType];
                    
                    labelElement.textContent = version.name;
                    labelElement.classList.remove(colorSet.error);
                    labelElement.classList.add(colorSet.success);

                    imgElement.onerror = () => {
                        console.error(`[Erreur de Chargement] √âchec du chargement de l'image : ${version.name} √† ${version.url}`);
                        imgElement.src = FALLBACK_PLACEHOLDER;
                        imgElement.alt = `Carte ${version.name} (Erreur de chargement)`;
                        labelElement.textContent = `${version.name} (Erreur)`;
                        labelElement.classList.remove(colorSet.success);
                        labelElement.classList.add(colorSet.error);
                        imgElement.onerror = null; 
                    };

                    imgElement.onload = () => {
                        imgElement.onerror = null; 
                        labelElement.classList.remove(colorSet.error);
                        labelElement.classList.add(colorSet.success);
                        labelElement.textContent = version.name;
                    };

                    imgElement.src = version.url;
                    imgElement.alt = `Carte ${version.name}`;
                };

                loadImage(imageAvant, versionA, labelAvant, 'avant');
                loadImage(imageApres, versionB, labelApres, 'apres');
            }
            
            /**
             * Initialise la position et les dimensions au chargement et au redimensionnement
             */
            const initializePosition = () => {
                // R√©initialiser l'√©tat du zoom/panoramique
                viewState.scale = MIN_SCALE;
                viewState.offsetX = 0;
                viewState.offsetY = 0;
                updateImageTransform();
                
                // Recalculer la position du conteneur et centrer le slider (50%)
                containerRect = container.getBoundingClientRect();
                const center = containerRect.width / 2;
                updateSliderPosition(containerRect.left + center);
            };


            // --- Attacher les √©couteurs d'√©v√©nements ---

            // √âcouteurs pour les changements de s√©lection
            selectAvant.addEventListener('change', updateImagesAndLabels);
            selectApres.addEventListener('change', updateImagesAndLabels);

            // Logique du slider (glisser/d√©poser)
            handle.addEventListener('mousedown', startSliderDrag);
            handle.addEventListener('touchstart', startSliderDrag);

            // Logique de Panoramique, Pinch-to-Zoom et Double-Tap (d√©placement)
            container.addEventListener('mousedown', startPanDrag);
            container.addEventListener('touchstart', startPanDrag);

            // Logique de Zoom (molette/Desktop)
            container.addEventListener('wheel', handleZoom, { passive: false });
            
            // √âcouteurs globaux pour le d√©placement et la fin du glissement (Tactile et Souris)
            document.addEventListener('mousemove', onDrag);
            document.addEventListener('touchmove', onDrag, { passive: false }); 
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchend', endDrag);
            
            
            // Initialisation de la page
            window.addEventListener('load', () => {
                populateSelects(); 
                initializePosition(); 
            });
            window.addEventListener('resize', initializePosition);
        });

    </script>
</body>
</html>

