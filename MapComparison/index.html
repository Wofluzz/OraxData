<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comparaison d'√âvolution de Carte Dynamique</title>
    <!-- Chargement de Tailwind CSS pour un design moderne et responsive -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* D√©finition du curseur personnalis√© */
        .comparison-slider-container {
            /* Utilisation d'une propri√©t√© CSS variable pour stocker la position du slider */
            --position: 50%;
            user-select: none;
            cursor: grab;
            touch-action: none; /* Emp√™che le d√©filement du navigateur lors du glisser */
        }
        
        /* Conteneur de l'image "Apr√®s" - C'est sa largeur qui change, utilise clip-path pour l'efficacit√© */
        .image-apres-wrapper {
            clip-path: inset(0 0 0 var(--position));
        }

        /* La poign√©e (handle) se positionne √† la valeur de la variable */
        .slider-handle {
            left: var(--position);
            transform: translateX(-50%); /* Centrage horizontal de la poign√©e */
        }

        /* Styles pour la poign√©e du slider */
        .handle-line {
            width: 4px; /* Ligne verticale */
        }

        .handle-circle {
            width: 40px;
            height: 40px;
        }
        
        /* Centrer le contenu dans le cercle */
        .handle-content {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }

        /* * Important: Les images ne doivent plus utiliser object-fit: cover, 
         * mais doivent √™tre styl√©es dynamiquement via JS pour le zoom/d√©placement.
         * Elles doivent occuper 100% de l'espace de leur conteneur au repos (scale=1).
         */
        .comparison-image {
            position: absolute;
            width: 100%;
            height: 100%;
            /* D√©finition des transitions pour un mouvement de zoom plus doux */
            transition: transform 0.15s ease-out;
            transform-origin: 0 0; /* Important pour que le zoom se fasse depuis le coin haut-gauche */
        }

    </style>
</head>
<body class="bg-gray-900 min-h-screen p-4 flex flex-col items-center font-sans">

    <header class="text-center mb-8">
        <h1 class="4xl font-extrabold text-blue-400">
            Comparateur d'√âvolution de Carte üó∫Ô∏è
        </h1>
        <p class="text-xl text-gray-400 mt-2">
            S√©lectionnez les versions de carte √† comparer. Utilisez la molette (ou glissez-d√©posez) pour zoomer et vous d√©placer.
        </p>
    </header>

    <main class="w-full max-w-4xl">

        <!-- S√©lecteurs de versions -->
        <div class="flex flex-col sm:flex-row justify-between gap-4 mb-6 p-4 bg-gray-800 rounded-xl shadow-lg border-2 border-gray-700">
            
            <!-- S√©lecteur AVANT -->
            <div class="flex-1">
                <label for="versionAvant" class="block text-sm font-medium text-red-400 mb-1">
                    Version AVANT :
                </label>
                <select id="versionAvant" class="w-full p-2 rounded-lg bg-gray-700 text-white border border-gray-600 focus:ring-red-500 focus:border-red-500 transition-colors">
                    <!-- Les options seront remplies par JavaScript -->
                </select>
            </div>
            
            <!-- S√©lecteur APR√àS -->
            <div class="flex-1">
                <label for="versionApres" class="block text-sm font-medium text-green-400 mb-1">
                    Version APR√àS :
                </label>
                <select id="versionApres" class="w-full p-2 rounded-lg bg-gray-700 text-white border border-gray-600 focus:ring-green-500 focus:border-green-500 transition-colors">
                    <!-- Les options seront remplies par JavaScript -->
                </select>
            </div>

        </div>


        <!-- Conteneur principal du slider -->
        <div id="comparisonContainer" 
             class="comparison-slider-container relative w-full aspect-video shadow-2xl rounded-xl overflow-hidden border-4 border-gray-700 bg-gray-800 transition-all duration-300 ease-in-out">

            <!-- 1. Image de base (VERSION AVANT) -->
            <!-- Ajout de la classe comparison-image pour la gestion du zoom/pan -->
            <img id="imageAvant" 
                 class="comparison-image absolute inset-0 z-10" 
                 src="" 
                 alt="Carte Avant Mise √† Jour">
            
            <!-- 2. Conteneur de l'image de dessus (VERSION APR√àS) -->
            <div class="image-apres-wrapper absolute inset-0 z-20 overflow-hidden bg-gray-600">
                <!-- Ajout de la classe comparison-image pour la gestion du zoom/pan -->
                <img id="imageApres" 
                     class="comparison-image absolute inset-0" 
                     src="" 
                     alt="Carte Apr√®s Mise √† Jour">
            </div>

            <!-- 3. La poign√©e (Handle) draggable/tactile -->
            <div id="sliderHandle" 
                 class="slider-handle absolute top-0 bottom-0 z-30 flex items-center justify-center 
                        text-white bg-transparent">
                
                <!-- La ligne verticale de la poign√©e -->
                <div class="handle-line h-full bg-white shadow-lg"></div>

                <!-- Le cercle central avec des fl√®ches -->
                <div class="handle-circle absolute bg-white p-1 rounded-full shadow-xl 
                            border-4 border-gray-900/50 hover:scale-110 transition-transform duration-150 ease-out">
                    <div class="handle-content text-gray-900">
                        <!-- Ic√¥nes des fl√®ches (SVG inline) -->
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6">
                            <polyline points="15 17 20 12 15 7"></polyline>
                            <polyline points="9 17 4 12 9 7"></polyline>
                        </svg>
                    </div>
                </div>
            </div>

            <!-- 4. √âtiquettes de version dynamiques -->
            <div id="labelAvant" class="absolute top-3 left-3 p-1.5 bg-red-800/80 text-white text-xs font-bold rounded-lg z-40 shadow-md"></div>
            <div id="labelApres" class="absolute top-3 right-3 p-1.5 bg-green-800/80 text-white text-xs font-bold rounded-lg z-40 shadow-md"></div>
            
        </div>
        
    </main>
    
    <p class="mt-6 text-sm text-gray-500">
        <span class="text-blue-400">Instructions :</span> Choisissez deux versions et utilisez le slider pour comparer l'√©volution de la carte. Pour zoomer/d√©zoomer, utilisez la molette de la souris. Pour d√©placer la carte (panoramique), maintenez le bouton de la souris enfonc√© et glissez.
    </p>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- D√©finition des versions de carte ---
            const mapVersions = [
                { id: 'v1', name: "Alpha (v0.0)", url: "./Maps/alpha.png" }, 
                { id: 'v2', name: "Beta (v1.0)", url: "./Maps/beta.png" },
                { id: 'v3', name: "Release (v1.1)", url: "./Maps/beta-v1.png" },
                { id: 'v4', name: "Saison 1 (v1.2)", url: "./Maps/beta-v2.png" },
                { id: 'v5', name: "Saison 2 (v1.3)", url: "./Maps/beta-v3.png" },
                { id: 'v6', name: "Saison 3 (v1.4)", url: "./Maps/beta-v4.png" },
            ];

            const FALLBACK_PLACEHOLDER = "https://placehold.co/1024x576/374151/D1D5DB?text=IMAGE+INDISPONIBLE%0A(V√©rifiez+l'URL)";
            const MIN_SCALE = 1.0;
            const MAX_SCALE = 5.0;
            const SCALE_STEP = 0.15;
            
            // --- √âl√©ments du DOM ---
            const container = document.getElementById('comparisonContainer');
            const handle = document.getElementById('sliderHandle');
            const selectAvant = document.getElementById('versionAvant');
            const selectApres = document.getElementById('versionApres');
            const imageAvant = document.getElementById('imageAvant');
            const imageApres = document.getElementById('imageApres');
            const labelAvant = document.getElementById('labelAvant');
            const labelApres = document.getElementById('labelApres');
            const style = container.style;
            
            // --- Variables de l'√©tat du composant ---
            let isSliderDragging = false; // Pour le curseur de comparaison
            let isPanDragging = false;    // Pour le d√©placement (panoramique) de la carte
            let containerRect;
            let lastX = 0;
            let lastY = 0;

            // √âtat de la vue (Zoom et Panoramique)
            let viewState = {
                scale: MIN_SCALE, // Niveau de zoom (1.0 = normal)
                offsetX: 0,       // D√©calage horizontal (en pixels)
                offsetY: 0        // D√©calage vertical (en pixels)
            };

            // --- Fonctions utilitaires ---

            /**
             * Applique les transformations de zoom et de panoramique aux deux images.
             */
            function updateImageTransform() {
                const transform = `translate(${viewState.offsetX}px, ${viewState.offsetY}px) scale(${viewState.scale})`;
                imageAvant.style.transform = transform;
                imageApres.style.transform = transform;
            }

            /**
             * Applique les contraintes de d√©placement pour ne pas sortir du cadre.
             */
            function clampPan() {
                if (!containerRect) return;

                // Calculer les limites du d√©placement bas√© sur le zoom
                const maxOffsetX = (containerRect.width * viewState.scale) - containerRect.width;
                const maxOffsetY = (containerRect.height * viewState.scale) - containerRect.height;
                
                // Limites positives (vers la gauche / haut)
                const minPanX = -maxOffsetX;
                const minPanY = -maxOffsetY;

                // Limiter le d√©placement. Si zoom√© √† 1.0, les limites sont 0.
                if (viewState.scale <= 1.0) {
                    viewState.offsetX = 0;
                    viewState.offsetY = 0;
                } else {
                    viewState.offsetX = Math.max(minPanX, Math.min(0, viewState.offsetX));
                    viewState.offsetY = Math.max(minPanY, Math.min(0, viewState.offsetY));
                }

                updateImageTransform();
            }

            /**
             * G√®re l'√©v√©nement de la molette pour zoomer/d√©zoomer.
             * @param {WheelEvent} e - L'√©v√©nement molette.
             */
            function handleZoom(e) {
                // Emp√™cher le d√©filement de la page
                e.preventDefault(); 
                
                // D√©terminer la direction du zoom
                const delta = e.deltaY < 0 ? SCALE_STEP : -SCALE_STEP;

                // Calculer le nouveau niveau de zoom
                let newScale = viewState.scale + delta;
                newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));

                // Si le zoom n'a pas chang√©, on sort
                if (newScale === viewState.scale) return;

                // Calculer le point focal pour le zoom
                containerRect = container.getBoundingClientRect();
                const mouseX = e.clientX - containerRect.left;
                const mouseY = e.clientY - containerRect.top;

                // Facteur de changement de zoom (pour garder le point sous la souris)
                const zoomFactor = newScale / viewState.scale;

                // Appliquer la correction de panoramique pour centrer le zoom sur le curseur
                viewState.offsetX = mouseX - (mouseX - viewState.offsetX) * zoomFactor;
                viewState.offsetY = mouseY - (mouseY - viewState.offsetY) * zoomFactor;
                
                // Mettre √† jour l'√©tat
                viewState.scale = newScale;
                clampPan(); // Appliquer les contraintes apr√®s le changement de zoom
            }

            // --- Logique du Slider de Comparaison ---

            /**
             * Calcule la nouvelle position du slider et l'applique au CSS.
             * @param {number} clientX - Position X du curseur/doigt.
             */
            function updateSliderPosition(clientX) {
                if (!containerRect) {
                    containerRect = container.getBoundingClientRect();
                }
                
                let position = clientX - containerRect.left;

                // Clamper la position entre 0 et la largeur du conteneur
                if (position < 0) {
                    position = 0;
                } else if (position > containerRect.width) {
                    position = containerRect.width;
                }
                
                const percent = (position / containerRect.width) * 100;
                style.setProperty('--position', `${percent}%`);
            }

            /**
             * Commence le glissement du slider (MouseDown/TouchStart).
             */
            const startSliderDrag = (e) => {
                // Si l'√©v√©nement vient du conteneur principal, c'est un panoramique, pas un glissement de slider
                if (e.currentTarget !== handle) return;

                isSliderDragging = true;
                handle.style.cursor = 'grabbing';
                container.style.cursor = 'grabbing';
                containerRect = container.getBoundingClientRect();
                
                if (e.type.startsWith('touch')) {
                    e.preventDefault();
                }
            };

            /**
             * G√®re le glissement du slider (MouseMove/TouchMove).
             */
            const onDrag = (e) => {
                if (!isSliderDragging && !isPanDragging) return;

                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                if (isSliderDragging) {
                    updateSliderPosition(clientX);
                }
                
                if (isPanDragging) {
                    // Calcul du d√©placement
                    const dx = clientX - lastX;
                    const dy = clientY - lastY;
                    
                    // Appliquer le d√©placement
                    viewState.offsetX += dx;
                    viewState.offsetY += dy;

                    // Clamper les valeurs pour rester dans les limites
                    clampPan();

                    // Mise √† jour des derni√®res positions
                    lastX = clientX;
                    lastY = clientY;
                }
            };

            /**
             * Termine le glissement (MouseUp/TouchEnd).
             */
            const endDrag = () => {
                isSliderDragging = false;
                isPanDragging = false;
                
                handle.style.cursor = 'grab';
                container.style.cursor = 'grab';
                container.classList.remove('cursor-grabbing');
            };

            // --- Logique de Panoramique (D√©placement) ---

            /**
             * Commence le panoramique (mousedown sur le conteneur principal).
             */
            const startPanDrag = (e) => {
                // Si le clic vient de la poign√©e du slider, on ignore le panoramique
                if (e.target === handle || handle.contains(e.target)) return;
                
                // Si le zoom est √† 1.0, on n'autorise pas le panoramique
                if (viewState.scale === MIN_SCALE) return;

                isPanDragging = true;
                container.classList.add('cursor-grabbing'); // Utiliser la classe Tailwind ou une custom si besoin
                containerRect = container.getBoundingClientRect();

                // Initialiser les derni√®res positions
                lastX = e.clientX || e.touches[0].clientX;
                lastY = e.clientY || e.touches[0].clientY;
            };

            // --- Fonctions d'initialisation et de mise √† jour ---

            /**
             * Rempli les menus d√©roulants avec les versions de carte.
             */
            function populateSelects() {
                mapVersions.forEach(version => {
                    const optionAvant = new Option(version.name, version.id);
                    const optionApres = new Option(version.name, version.id);
                    selectAvant.add(optionAvant);
                    selectApres.add(optionApres);
                });

                // D√©finir les valeurs par d√©faut
                if (mapVersions.length >= 2) {
                    selectAvant.value = mapVersions[mapVersions.length - 2].id;
                    selectApres.value = mapVersions[mapVersions.length - 1].id;
                } else if (mapVersions.length === 1) {
                    selectAvant.value = mapVersions[0].id;
                    selectApres.value = mapVersions[0].id;
                }
                
                updateImagesAndLabels();
            }

            /**
             * Met √† jour les images, les √©tiquettes et configure la gestion des erreurs.
             */
            function updateImagesAndLabels() {
                const idAvant = selectAvant.value;
                const idApres = selectApres.value;

                const versionA = mapVersions.find(v => v.id === idAvant);
                const versionB = mapVersions.find(v => v.id === idApres);
                
                const COLOR_CLASSES = {
                    avant: { success: 'bg-red-800/80', error: 'bg-gray-600/90' },
                    apres: { success: 'bg-green-800/80', error: 'bg-gray-600/90' }
                };

                const loadImage = (imgElement, version, labelElement, baseType) => {
                    if (!version) return;
                    
                    const colorSet = COLOR_CLASSES[baseType];
                    
                    labelElement.textContent = version.name;
                    labelElement.classList.remove(colorSet.error);
                    labelElement.classList.add(colorSet.success);

                    imgElement.onerror = () => {
                        console.error(`[Load Error] √âchec du chargement de l'image : ${version.name} √† ${version.url}`);
                        imgElement.src = FALLBACK_PLACEHOLDER;
                        imgElement.alt = `Carte ${version.name} (Erreur de chargement)`;
                        labelElement.textContent = `${version.name} (Erreur)`;
                        labelElement.classList.remove(colorSet.success);
                        labelElement.classList.add(colorSet.error);
                        imgElement.onerror = null; 
                    };

                    imgElement.onload = () => {
                        imgElement.onerror = null; 
                        labelElement.classList.remove(colorSet.error);
                        labelElement.classList.add(colorSet.success);
                        labelElement.textContent = version.name;
                    };

                    imgElement.src = version.url;
                    imgElement.alt = `Carte ${version.name}`;
                };

                loadImage(imageAvant, versionA, labelAvant, 'avant');
                loadImage(imageApres, versionB, labelApres, 'apres');
            }
            
            /**
             * Initialise la position et les dimensions au chargement et au redimensionnement
             */
            const initializePosition = () => {
                // R√©initialiser l'√©tat du zoom/panoramique
                viewState.scale = MIN_SCALE;
                viewState.offsetX = 0;
                viewState.offsetY = 0;
                updateImageTransform();
                
                // Centrer le slider (50%)
                const center = container.clientWidth / 2;
                updateSliderPosition(container.getBoundingClientRect().left + center);
            };


            // --- Attacher les √©couteurs d'√©v√©nements ---

            // √âcouteurs pour les changements de s√©lection
            selectAvant.addEventListener('change', updateImagesAndLabels);
            selectApres.addEventListener('change', updateImagesAndLabels);

            // Logique du slider (glisser/d√©poser)
            handle.addEventListener('mousedown', startSliderDrag);
            handle.addEventListener('touchstart', startSliderDrag);

            // Logique de Panoramique (d√©placement)
            container.addEventListener('mousedown', startPanDrag);
            // Ajout du support tactile pour le panoramique
            container.addEventListener('touchstart', startPanDrag);

            // Logique de Zoom (molette)
            container.addEventListener('wheel', handleZoom);
            
            // √âcouteurs globaux pour le d√©placement et la fin du glissement
            document.addEventListener('mousemove', onDrag);
            document.addEventListener('touchmove', onDrag);
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchend', endDrag);
            
            
            // Initialisation de la page
            window.addEventListener('load', () => {
                populateSelects(); // Remplir les dropdowns avec les donn√©es
                initializePosition(); // Centrer le slider et r√©initialiser le zoom
            });
            window.addEventListener('resize', initializePosition);
        });

    </script>

</body>
</html>

